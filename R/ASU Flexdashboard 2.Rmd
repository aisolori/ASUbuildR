---
title: "ASU Designation Program"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: scroll
runtime: shiny
---

```{r setup, include=FALSE}
library(shiny)
library(flexdashboard)
library(formattable)
library(leaflet)
library(mapgl)
library(tigris)
library(sf)
library(sfdep)
library(tidyverse)
library(readxl)
library(mapview)

options(shiny.maxRequestSize = 50 * 1024^2)  # Set to 50MB or your desired limit

# Initialize reactive values
uploaded_data <- reactiveVal(NULL)
state <- reactiveVal(NULL)
tract_year <- reactiveVal(NULL)
tract_data <- reactiveVal(NULL)
asu_data <- reactiveVal(NULL)
asu_tracts <- reactiveVal(NULL)
asu_summary <- reactiveVal(NULL)
full_data <- reactiveVal(NULL)
full_data_reset <- reactiveVal()
selected_tracts <- reactiveVal(NULL)
edit_table <- reactiveVal(NULL)
edit_summary <- reactiveVal(NULL)
current_selection <- reactiveVal(NULL)




# Load static data
excel_names <- c("record",
                 "geoid",
                 "st_fips",
                 "cnty_fips",
                 "tract_fips",
                 "name",
                 "tract_pop_dec",
                 "tract_pop_cur",
                 "tract_emp",
                 "tract_unemp",
                 "tract_urate",
                 "tract_urate_error",
                 "cnty_pop_dec",
                 "cnty_pop_cur",
                 "cnty_emp",
                 "cnty_unemp",
                 "cnty_urate",
                 "cnty_urate_error",
                 "pop_shr",
                 "emp_shr",
                 "unemp_shr",
                 "laus_primary",
                 "cnty_emp_ave",
                 "cnty_unemp_ave",
                 "tract_ASU_clf",
                 "tract_ASU_emp",
                 "tract_ASU_unemp",
                 "tract_ASU_urate")


```

Data Initialization
=============================

## Controls {data-width=150}

This screen allows you to import the BLS-provided ASU file, generally named like *NV_asu23.xlsx* which will be the only external data import step necessary.  The script will read the file, extract the state and corresponding year, and standardize the column names to avoid annual updates to the script.

If the necessary data is not in columns A through AB within the Excel file, this process will not work correctly.

Once the file is loaded, a preview of the data will appear on the right, the state and year will display below, and the analyst may proceed to the next tab (Load Initial ASU).

```{r}
fileInput("file", "Choose Excel File", accept = c(".xls", ".xlsx"))

textOutput("selected_state")

textOutput("selected_year")


```

## Output {data-width=850}

```{r}

tableOutput("data_preview")

observeEvent(input$file, {
  req(input$file)
  df <- read_excel(input$file$datapath, range = "A2:AB25000", col_names = excel_names) %>%
    filter(!is.na(geoid)) %>%
    mutate(GEOID = str_remove(geoid, "14000US")) %>%
    select(GEOID,
           st_fips,
           cnty_fips,
           tract_fips,
           name,
           tract_pop_cur,
           tract_ASU_clf,
           tract_ASU_emp,
           tract_ASU_unemp,
           tract_ASU_urate)
  
  uploaded_data(df)
  
  uploaded_data() %>%
    pull(st_fips) %>%
    unique() %>%
    state()
  
  read_excel(input$file$datapath, range = "H1:H1", col_names = "year") %>%
    pull(year) %>%
    str_remove("tract_pop") %>%
    tract_year()
  
  output$data_preview <- renderTable({
    head(uploaded_data(),50)
    
  })
  
  output$selected_state <- renderText({
    paste0("Selected FIPS is: ", state())
  })
  
    output$selected_year <- renderText({
    paste0("Tract Population Year is: ", tract_year())
  })
  
})


```

Load Initial ASU
============================

## Controls {data-width=200}

This button will launch two processes, which will take up to 5 minutes to complete. For smaller states, it may take under 15 seconds.

First, the application will download census shapefiles by tract for the appropriate state and year. Next, after combining the BLS file with these shapefiles, it will iteratively search for contiguous geographic regions until the combined unemployment rate in each region is as close to 6.45% as possible.

When this process is complete, a map will appear to the right, and a summary of the created ASU regions will appear below.  It is important to note, these will still include areas that do not qualify as an independent ASU (there is no check for population), but it gives the analyst a starting place for analysis.

Once this step is done, you may proceed to the next step.

```{r}
actionButton("process", "Load Tracts and Initialize ASU")
tableOutput("asu")

observeEvent(input$process, {
  
  tract_list <- tracts(state = state(), year = tract_year()) %>% mutate(row_num = row_number(), continuous = st_contiguity(geometry))
  BLS_Data <- uploaded_data()
  data_merge <- left_join(tract_list, BLS_Data, by = "GEOID")
  data_merge <- data_merge %>% arrange(desc(tract_ASU_urate), desc(tract_ASU_unemp))
  
  start <- data_merge %>% head(1)
  existing <- start %>% st_drop_geometry() %>% pull(row_num)
  ASU_assigned <- start[0,]
  rate <- 100
  asunum <- 1
  filtered_data_merge <- data_merge
  
  ### Loop
  
  while(filtered_data_merge$tract_ASU_urate[1] > 6.45){
    orderid <- 1
    start <- head(filtered_data_merge, 1)
    start$orderid <- orderid
    combined_area <- bind_rows(start)
    existing <- combined_area %>% pull(row_num)
    add_tract <- TRUE
    
    while(rate > 6.45){
      add_tract <- TRUE
      neighbor_list <- combined_area %>% st_drop_geometry() %>% pull(continuous) %>% unlist()
      neighbor_list <- neighbor_list[!neighbor_list %in% existing]
      adjacent <- filtered_data_merge %>% filter(row_num %in% neighbor_list)
      
      if(nrow(adjacent) == 0){
        add_tract <- FALSE
        break
      } else if(min(adjacent$tract_ASU_clf) < 1){
        next_tract <- adjacent %>%
          filter(tract_ASU_clf < 1) %>%
          head(1)
      } else {
        next_tract <- adjacent %>% 
          arrange(desc(tract_ASU_urate),
                  desc(tract_ASU_unemp)) %>% 
          head(1)
      }
      
      if(add_tract){
        orderid <- orderid + 1
        next_tract$orderid <- orderid
        combined_area <- bind_rows(combined_area, next_tract)
        rate <- sum(combined_area$tract_ASU_unemp) / sum(combined_area$tract_ASU_clf) * 100
        existing <- combined_area %>% pull(row_num)
      }
      
    }
    
    if(rate < 6.45){
      combined_area <- head(combined_area, -1)
    }
    preASU_assign <- cbind(combined_area, asunum)
    ASU_assigned <- bind_rows(ASU_assigned, preASU_assign)
    ASU_assigned_names <- ASU_assigned$name
    asunum <- asunum + 1
    filtered_data_merge <- data_merge %>% filter(!name %in% ASU_assigned_names)
    filtered_data_merge <- filtered_data_merge %>% arrange(desc(tract_ASU_urate))
    rate <- 100
  }
  
  # Reactive full_data gets all tracts, merged with ASU data.
  
  data_merge %>%
    select(GEOID,name,  starts_with("tract_")) %>%
    left_join(ASU_assigned %>% st_drop_geometry() %>% select(GEOID, asunum)) %>%
    mutate(asunum = if_else(is.na(asunum), 0, asunum),
           asunum = as.integer(asunum),
           tract_ASU_clf = as.integer(tract_ASU_clf),
           tract_pop_cur = as.integer(tract_pop_cur),
           tract_ASU_unemp - as.integer(tract_ASU_unemp)) %>%
    full_data()
  
  # Reactive full_data_reset gets all tracts, merged with ASU data, saved for resetting modifications.
  
  data_merge %>%
    select(GEOID,name,  starts_with("tract_")) %>%
    left_join(ASU_assigned %>% st_drop_geometry() %>% select(GEOID, asunum)) %>%
    mutate(asunum = if_else(is.na(asunum), 0, asunum),
           asunum = as.integer(asunum),
           tract_ASU_clf = as.integer(tract_ASU_clf),
           tract_pop_cur = as.integer(tract_pop_cur),
           tract_ASU_unemp - as.integer(tract_ASU_unemp)) %>%
    full_data_reset()
  
  # Reactive asu_data contains geometry and continuity data
  ASU_assigned %>%
    asu_data()
  
  # Reactive asu_tracts contains assigned tracts without continuity column for mapping
  ASU_assigned %>%
    select(GEOID, name, tract_pop_cur, tract_ASU_clf, tract_ASU_unemp, tract_ASU_urate, asunum) %>%
    asu_tracts()
  
  # Reactive asu_summary contains summarized ASU data for summary table    
  ASU_assigned %>%
    st_drop_geometry() %>%
    select(name, tract_pop_cur, tract_ASU_clf, tract_ASU_unemp, asunum) %>%
    group_by(asunum) %>%
    summarize(
      tracts = n(),
      population = sum(tract_pop_cur, na.rm = TRUE),
      lf = sum(tract_ASU_clf, na.rm = TRUE),
      unemp = sum(tract_ASU_unemp, na.rm = TRUE),
      ur = round(unemp/lf*100, 2)
    ) %>%
    mutate(asunum = as.integer(asunum)) %>%
    select(asunum, tracts, population, ur) %>%
    asu_summary()
  
  output$asu <- renderTable({
    asu_summary()
  })
  
  dynamic_palette <- colorNumeric(palette = "viridis", domain = ASU_assigned$asunum)
  
  
# Convert to MapLibre
output$initial_map <- renderMaplibre({
  
  # Prepare the data with colors
  map_data <- full_data()
  
  # # Add fill colors to the data
  # map_data$fill <- ifelse(
  #   map_data$GEOID %in% ASU_assigned$GEOID,
  #   dynamic_palette(ASU_assigned$asunum[match(map_data$GEOID, ASU_assigned$GEOID)]),
  #   "#444444"
  # )
  
  number_asus <- max(map_data$asunum)
  number_categories <- min(c(number_asus,8))
  asu_per_category <- number_asus/number_categories
  brewer_pal <- RColorBrewer::brewer.pal(number_categories, "Accent")
  
  map_data <- map_data %>%
    mutate(asunum = if_else(asunum == 0, NA, asunum))
  
  # Create the maplibre map
  maplibre(style = carto_style("positron")) |>
    fit_bounds(map_data, animate = FALSE) |> 
    add_fill_layer(
      id = "basemap",
      source = map_data,
      fill_color = step_expr(
        column = "asunum",
        base = brewer_pal[1],
        stops = brewer_pal[2:number_categories],
        values = seq(1+asu_per_category,number_asus,asu_per_category),
        na_color = "#444444"
      ),
      fill_opacity = 0.5,
      fill_outline_color = "black",
      popup = concat(
        "<strong>ASU Number: </strong>",get_column("asunum"), "<br>",
        "<strong>Tract GEOID: </strong>",get_column("GEOID"),"<br>",
        "<strong>Tract Unemployment Rate: </strong>",number_format(get_column("tract_ASU_urate"), style = "decimal", maximum_fraction_digits = 2),"%<br>",
        "<strong>Tract Unemployment: </strong>",number_format(get_column("tract_ASU_unemp"), style = "decimal", maximum_fraction_digits = 0),"<br>")
    ) |>
    add_legend(
      "ASU Number",
      values = round(seq(1,number_asus,asu_per_category)),
      colors = brewer_pal,
      type = "categorical"
    )

})  


    
    # # Add interactivity - tooltip on hover
    # add_tooltip(
    #   c("asunum", "GEOID", "tract_ASU_urate"),
    #   template = "ASU: {{asunum}} || GEOID: {{GEOID}} || Unemployment Rate: {{tract_ASU_urate}}"
    # ) #%>%
    # 
    # # Add hover effects using paint properties
    # add_fill_layer(
    #   source = map_data,
    #   fill_color = list(
    #     "case",
    #     list("boolean", list("feature-state", "hover"), false),
    #     "white",  # hover color
    #     list("get", "fill_color")  # default color
    #   ),
    #   fill_opacity = 0.5,
    #   line_color = list(
    #     "case", 
    #     list("boolean", list("feature-state", "hover"), false),
    #     "white",  # hover border color
    #     "black"   # default border color
    #   ),
    #   line_width = list(
    #     "case",
    #     list("boolean", list("feature-state", "hover"), false),
    #     2,  # hover border width
    #     1   # default border width
    #   )
    # )

  
  
})





```

## Output {data-width=800}

```{r}

maplibreOutput("initial_map", height = "100vh")

```

Modify ASU Selections - Tracts
==========================

## Controls {data-width=150}

Selecting tracts on the map to the right will allow you to modify the designated ASU from the inital selection methodology. Several tools are provided to manage this process.

You may select tracts by clicking on the map, or by selecting a numbered ASU from the dropdown below to select all tracts in that ASU.  The *Preview* button will calculate metrics for all selected tracts.

You may also choose to *Filter* selected tracts to find the lowest unemployment rates in an area.  This can be useful to omit low-unemployment tracts after adding tracts to connect isolated regions.

To modify the assigned ASU, with tracts selected, use the *Update* button to update the ASU of selected tracts. To remove a tract from any ASUs, assign it to ASU zero.

To undo your work and return to the initially-designated data, use the *Reset* button.

```{r}
# Select an ASU
asu_selection_ui <- reactive({
  selectInput("select_asunum", "Select ASU Number:",
              choices = c("None", asu_choices()),
              selected = "None")
})
renderUI(asu_selection_ui())
renderUI(HTML("<hr>"))

# Change ASU
numericInput("new_asu", "Change ASU Value:", value = 0, min = 0)
actionButton("update", "Update Selected Tracts")
renderUI(HTML("<hr>"))

# Clear Selected Tracts
actionButton("clear", "Clear Selected Tracts")
renderUI(HTML("<hr>"))

# Show Data for Selection
actionButton("preview", "Show Data for Selected Tracts")
asu_choices <- reactive(full_data() %>% pull(asunum) %>% unique() %>% sort())


# Show Lowest UR Tracts in Selection
numericInput("percentile", "Percentile Threshold:", value = 5, min = 1, max = 100, step = 1)
actionButton("filter_percentile", "Show Tracts with Lowest UR")
renderUI(HTML("<hr>"))


# Single GROID Selection
textInput("manual_geoid", "Enter a GEOID:", placeholder = "32031990000")
actionButton("select_geoid", "Select a Single Tract")
renderUI(HTML("<hr>"))

# Reset to Initial Load
actionButton("reset", "Reset to Initial Data")



### Need to add new inputs / outputs
# Add table of currently selected tracts
# ensure basemap includes all tracts, not just those with an ASU assigned


```

## Output {data-width=850}

```{r}

# 
# edit_table <- reactiveVal(data.frame(GEOID = character(),
#                                      tract_pop_cur = numeric(),
#                                      tract_ASU_clf = numeric(),
#                                      tract_ASU_unemp = numeric(),
#                                      tract_ASU_urate = numeric(),
#                                      stringsAsFactors = FALSE))

maplibreOutput("edit_map", height = "90vh")

tableOutput("selection_data")

tableOutput("selection_summary")



output$edit_map <- renderMaplibre({
  
  req(full_data())
  
  # Fix: Use full_data() instead of map_data (assuming map_data should be full_data)
  number_asus <- max(full_data()$asunum)
  number_categories <- min(c(number_asus, 8))
  asu_per_category <- number_asus/number_categories
  brewer_pal <- RColorBrewer::brewer.pal(number_categories, "Accent")
  
  dynamic_palette <- colorNumeric(palette = "viridis", domain = full_data()$asunum)
  
 maplibre(style = carto_style("positron")) |>
    fit_bounds(full_data(), animate = FALSE) |> 
    add_fill_layer(
      id = "basemap",
      source = full_data(),
      fill_color = step_expr(
        column = "asunum",
        base = "#808080",  # Grey for asunum == 0
        stops = brewer_pal[1:number_categories],
        values = c(0.5, seq(1+asu_per_category, number_asus, asu_per_category)),
        na_color = "#444444"
      ),
      fill_opacity = 0.5,
      fill_outline_color = "black",
      tooltip = concat(
        "<strong>ASU Number: </strong>", get_column("asunum"), "<br>",
        "<strong>Tract GEOID: </strong>", get_column("GEOID"), "<br>",
        "<strong>Tract Unemployment Rate: </strong>", number_format(get_column("tract_ASU_urate"), style = "decimal", maximum_fraction_digits = 2), "%<br>",
        "<strong>Tract Unemployment: </strong>", number_format(get_column("tract_ASU_unemp"), style = "decimal", maximum_fraction_digits = 0), "<br>"
      )
    )
})

# Corrected click event handler for MapLibre
observeEvent(input$edit_map_feature_click, {
  click <- input$edit_map_feature_click
  current_selection <- selected_tracts()
  
  # Extract the GEOID from the clicked feature properties
  clicked_geoid <- click$properties$GEOID
  
  # Add or remove the selected tract
  if (clicked_geoid %in% current_selection) {
    current_selection <- setdiff(current_selection, clicked_geoid)
  } else {
    current_selection <- c(current_selection, clicked_geoid)
  }
  
  selected_tracts(current_selection)
  
  # Update the map highlighting
  if (length(current_selection) > 0) {
    selected_data <- subset(full_data(), GEOID %in% selected_tracts())
    
    maplibre_proxy("edit_map") %>%
      clear_layer("selected") %>%
      add_line_layer(
        id = "selected",
        source = selected_data,
        line_color = "red",
        line_width = 3,
        line_opacity = 1
      )
  } else {
    # Clear the selection layer if no tracts are selected
    maplibre_proxy("edit_map") %>%
      clear_layer("selected")
  }
  
  # Update the selection table
  output$selection_table <- renderTable({
    selected_tracts()
  })
})

# Clear Selected Tracts on Button Click
observeEvent(input$clear, {
  
  selected_tracts(NULL)
  
  # Update the map highlighting
    maplibre_proxy("edit_map") %>%
      clear_layer("selected")
    return()
})

# Fix: Single observeEvent for selecting tracts by ASU number
observeEvent(input$select_asunum, {
  req(full_data())
  
  # Skip if "None" is selected
  if (input$select_asunum == "None") {
    selected_tracts(NULL)
    maplibre_proxy("edit_map") %>%
      clear_layer("selected")
    return()
  }
  
  # Get all tracts with the selected ASU number
  selected_tract_ids <- full_data() %>%
    filter(asunum == as.numeric(input$select_asunum)) %>%
    pull(GEOID)
  
  # Update the selected_tracts reactive value
  selected_tracts(selected_tract_ids)
  
  # Get the filtered data for selected tracts
  selected_data <- subset(full_data(), GEOID %in% selected_tract_ids)
  
  # Highlight the selected tracts on the map using maplibre proxy
  maplibre_proxy("edit_map") %>%
    clear_layer("selected") %>%
    add_line_layer(
      id = "selected",
      source = selected_data,
      line_color = "red",
      line_width = 3,
      line_opacity = 1
    ) |> 
    fit_bounds(selected_data, animate = TRUE)
})

# New observeEvent for manually selecting a GEOID using MapLibre
observeEvent(input$select_geoid, {
  req(full_data())
  
  # Get the selected tract's data
  selected_tract <- full_data() %>%
    filter(GEOID == input$manual_geoid)
  
  # If the tract exists, highlight it and fit bounds
  if (nrow(selected_tract) > 0) {
    # Highlight the selected tract on the map using maplibre proxy
    maplibre_proxy("edit_map") %>%
      clear_layer("selected") %>%
      add_line_layer(
        id = "selected",
        source = selected_tract,
        line_color = "red",
        line_width = 3,
        line_opacity = 1
      ) %>%
      fit_bounds(selected_tract, animate = TRUE)
    
    # Update the selected_tracts reactive value
    selected_tracts(selected_tract$GEOID)
  }
})



# Filter selected tracts by percentile
observeEvent(input$filter_percentile, {
  
  req(input$percentile, full_data(), selected_tracts())
  
  # Calculate the threshold for the percentile based on selected tracts
  selected_data <- full_data() %>%
    filter(GEOID %in% selected_tracts())
  
  threshold <- quantile(selected_data$tract_ASU_urate, input$percentile/100)
  
  # Filter currently selected tracts by the new percentile threshold
  filtered_selected <- selected_data %>%
    filter(tract_ASU_urate <= threshold,
           tract_ASU_urate > 0) %>%
    pull(GEOID)
  
  # Update the selected_tracts reactive value with filtered selection
  selected_tracts(filtered_selected)
  
  # Get the filtered data for selected tracts
  filtered_data <- subset(full_data(), GEOID %in% filtered_selected)
  
  # Update the map to highlight the newly filtered tracts using maplibre proxy
  maplibre_proxy("edit_map") %>%
    clear_layer("selected") %>%
    add_line_layer(
      id = "selected",
      source = filtered_data,
      line_color = "red",
      line_width = 3,
      line_opacity = 1
    )
  
  # Update the selection table
  output$selection_table <- renderTable({
    filtered_selected
  })
  
})



observeEvent(input$preview, {
  req(selected_tracts())

  replacement_data <- full_data() %>%
    st_drop_geometry() %>%
    subset(GEOID %in% selected_tracts())

  edit_table(replacement_data)

  edit_table() %>%
    ungroup() %>%
    summarize(
      tracts = n(),
      population = sum(tract_pop_cur, na.rm = TRUE),
      lf = sum(tract_ASU_clf, na.rm = TRUE),
      unemp = sum(tract_ASU_unemp, na.rm = TRUE),
      ur = round(unemp/lf*100, 5)
    ) %>%
    edit_summary()

  # Show Preview of Selected Tracts
  output$selection_summary <- renderTable({
    edit_summary()
  })

})


observeEvent(input$update, {
  req(selected_tracts(), full_data())
  
  # Update the full_data reactive value
  updated_data <- full_data() %>%
    filter(GEOID %in% selected_tracts()) %>%
    mutate(asunum = as.numeric(input$new_asu)) %>%
    rbind(
      full_data() %>%
        filter(!(GEOID %in% selected_tracts()))
    )
  
  # Update the reactive value
  full_data(updated_data)
  
  # Clear selected tracts
  selected_tracts(NULL)
  
  # Update map to remove highlight on selected tracts
  maplibre_proxy("edit_map") %>%
    clear_layer("selected")
})

observeEvent(input$reset, {
  req(full_data_reset(), full_data())
  
  # Reset the full_data reactive value
  full_data(full_data_reset())
  
  # Clear selected tracts
  selected_tracts(NULL)
  
  # Update map to remove highlight on selected tracts
  maplibre_proxy("edit_map") %>%
    clear_layer("selected")
})




```

Save and Load Data
==========================

## Controls  {data-width=150}

These buttons allow you to save the map in progress so that you can load it again in the future to continue your work.

The save file will land in your working directory, and the path will be noted when you save.

After loading data, you can go directly to the ASU Modification tab to continue making edits.

```{r}

actionButton("save_data", "Save Data")
fileInput("load_data", "Load Data", accept = c(".rds"))

# Observer for saving the data
observeEvent(input$save_data, {
  req(full_data())
  
  # Specify the file path in the current working directory
  save_path <- file.path(getwd(), "saved_data.rds")
  
  # Save the full_data object to an RDS file
  saveRDS(full_data(), save_path)
  
  # Provide feedback to the user
  showModal(modalDialog(
    title = "Data Saved",
    paste("Your data has been saved to:", save_path)
  ))
})

# Observer for loading the data
observeEvent(input$load_data, {
  req(input$load_data)
  
  # Read the RDS file into a data frame
  loaded_data <- tryCatch({
    readRDS(input$load_data$datapath)
  }, error = function(e) {
    showModal(modalDialog(
      title = "Error Loading Data",
      "Failed to load the data. Please check the file format.",
      easyClose = TRUE
    ))
    return(NULL)
  })
  
  # If loaded_data is NULL (failed to load), exit the observer
  req(!is.null(loaded_data))
  
  # Ensure the loaded data is an sf object
  if (!inherits(loaded_data, "sf")) {
    showModal(modalDialog(
      title = "Error Loading Data",
      "The loaded data is not a valid sf object.",
      easyClose = TRUE
    ))
    return(NULL)
  }
  
  # Update full_data with the loaded data
  full_data(loaded_data)
  
  # Provide feedback to the user
  showModal(modalDialog(
    title = "Data Loaded",
    "Your data has been successfully loaded.",
    easyClose = TRUE
  ))
    
    # Update the map to reflect the loaded data
  dynamic_palette <- colorNumeric(palette = "viridis", domain = full_data()$asunum)
  
    leafletProxy("edit_map") %>%
      clearGroup("tracts") %>%
      addPolygons(data = full_data(), 
                  layerId = ~GEOID, weight = 1, color = "black", fillOpacity = 0.5, 
                  fillColor = ~ifelse(asunum != 0, 
                                      dynamic_palette(asunum), 
                                      "#444444"), 
                  label = ~paste0("ASU: ", asunum,
                                  " || GEOID: ", GEOID,
                                  " || Unemployment Rate: ", tract_ASU_urate,
                                  " || Unemployment: ", tract_ASU_unemp,
                                  " || Population: ", tract_pop_cur),
                  highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE))
  })

```

## Output {data-width=850}

```{r}

```



ASU Review and Finalization
==========================

## Controls {data-width=150}

This screen will allow you to review your selected ASUs.  It uses a threshold of 6.45% unemployment and a population of 10,000, but these numbers can be modified in case they change in the future.

*Generate ASU Summary* will show a table of all ASUs, and whether they pass or fail the ASU definitions for unemployment and population. Please pay attention to these measures - an unemployment rate of 6.449% will display as 6.45%, but will fail the validation.

Note, you *may* go back and forth between the selection and review screens.

When ready to create an output file, the *Generate LSS .txt File* button will create a formatted batch file for upload to LSS.

```{r}

numericInput("asu_ur", "ASU Unemployment Rate Threshold:", value = 6.45, min = 0)

numericInput("asu_pop", "ASU Population Threshold:", value = 10000, min = 0)

actionButton("run_asu_summary", "Generate ASU Summary")

actionButton("lss_txt", "Generate LSS .txt File")

actionButton("review_txt", "Create Summary CSV")

```

## Output {data-width=850}

```{r}

tableOutput("asu_review")

summarized_asu <- reactiveVal(NULL)

observeEvent(input$run_asu_summary, {
  
  req(full_data())
  
  summary_table <- full_data() %>%
    st_drop_geometry() %>%
    group_by(asunum) %>%
    filter(asunum > 0.5) %>%
    summarize(
      tracts = n(),
      population = sum(tract_pop_cur, na.rm = TRUE),
      lf = sum(tract_ASU_clf, na.rm = TRUE),
      unemp = sum(tract_ASU_unemp, na.rm = TRUE),
      ur = round(unemp/lf*100, 5)
    ) %>%
    ungroup() %>%
    mutate(
      asu_num = round(asunum),
      ur_qualified = if_else(ur >= input$asu_ur, TRUE, FALSE),
      pop_qualified = if_else(population >= input$asu_pop, TRUE, FALSE),
      asu_qualified = ur_qualified & pop_qualified
    )
  
  summarized_asu(summary_table)
})

output$asu_review <- renderTable({
  summarized_asu()
})

observeEvent(input$lss_txt, {
  
    req(full_data())

  # Function to generate text content
  generate_txt <- function() {
    df <- full_data() %>%
      st_drop_geometry() %>%
      select(GEOID, asunum) %>%
      filter(asunum > 0) %>%
      mutate(asunum = as.integer(asunum),
             GEOID = paste0("14000US", GEOID),
             asunum = paste0("SU", state(), sprintf("%04d", asunum)),
             GEOID = paste(asunum, GEOID, sep = " + ")) %>% 
      arrange(asunum, GEOID) %>%
      select(-asunum)

    txt_content <- capture.output(write.table(df, quote=FALSE, row.names=FALSE, col.names = FALSE))
    txt_content <- paste(txt_content, collapse="\n")
    return(txt_content)
  }

  # Create the content
  txt_content <- generate_txt()

  filePath <- file.path("lss_batch_file.txt")
  
  # Download the file
  writeLines(txt_content, filePath)
  fileUrl <- "lss_batch_file.txt"
  js <- sprintf("window.location.href='%s';", fileUrl)
  shinyjs::runjs(js)

})


observeEvent(input$review_txt, {

    req(full_data())

    # Function to generate CSV content
    generate_csv <- function() {
        df <- full_data() %>%
            st_drop_geometry() %>%
          arrange(asunum, GEOID)
        
        return(df)
    }

    # Create the content
    df <- generate_csv()

    filePath <- file.path("ASU Review File.csv")
    
    # Write the CSV file
    write.csv(df, filePath, row.names = FALSE)
    
    fileUrl <- "ASU Review File.csv"
    
    # Trigger the download
    js <- sprintf("window.location.href='%s';", fileUrl)
    shinyjs::runjs(js)

})


####################
## Future Development

# Export Excel Worksheet with tract details and selections.
# Allow "Save" of data with txt/Excel files so single session is not required.
# Better table formatting.
# highlight high unemployment tracts in non-included areas.
# Check for contiguity of selected ASUs after manual edits.
# Export high-resolution images of ASUs for review.
# Add control to zoom map to selected tracts?
# Use reactlog package to monitor reactive interactions in the code for cleanup. https://mastering-shiny.org/reactive-graph.html


```




