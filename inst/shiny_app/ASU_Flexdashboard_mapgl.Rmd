---
title: "ASUbuildR"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: scroll
runtime: shiny
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
# Figure out full paths to src/ C++ files, going up two levels
src_cpp_files <- c("choose_best_neighbor.cpp",
                   "build_edges.cpp",
                   "choose_best_drop.cpp")

src_paths <- normalizePath(file.path("..", "..", "src", src_cpp_files),
                           winslash = "/", mustWork = FALSE)

# Check that all source files are there
in_repo <- all(file.exists(src_paths))

maybe_sourceCpp <- function(fun, path) {
  if (!exists(fun, mode = "function") && file.exists(path)) {
    message("Compiling ", basename(path))
    Rcpp::sourceCpp(path)
  }
}

if (in_repo) {
  message("→ Dev mode: compiling C++ helpers from src/")
  maybe_sourceCpp("choose_best_neighbor", src_paths[1])
  maybe_sourceCpp("build_edges",          src_paths[2])
  maybe_sourceCpp("choose_best_drop",     src_paths[3])
} else {
  message("→ Installed package mode (shared library already loaded)")

}

# ---- dev mode: source helper functions relative to this file ----------
is_dev_mode <- file.exists("../../DESCRIPTION") && dir.exists("../../R")

if (is_dev_mode) {
  message("→ Dev mode: sourcing from ../../R/")
  r_dir <- normalizePath("../../R", winslash = "/", mustWork = TRUE)

  source(file.path(r_dir, "run_tract_hunter.R"))
  source(file.path(r_dir, "run_asu_original.r"))
} else {
  message("→ Installed package mode: functions should already be available")
}


## ---- tigris cache ----------------------------------------------------
## put cached TIGER/Line ZIPs in a per-user cache folder that is always
## writable, even after the package is installed read-only.

# 1. choose a sensible user-cache path (rappdirs works everywhere)
cache_dir <- rappdirs::user_cache_dir("ASUbuildR", "tigris")

# 2. create it if it doesn't exist
if (!dir.exists(cache_dir))
  dir.create(cache_dir, recursive = TRUE, showWarnings = FALSE)

# 3. tell tigris to use it *this session*
options(tigris_cache_dir = cache_dir)

# tell tigris to look there first before re‑downloading
options(tigris_use_cache = TRUE)


# cache every tigris download automatically
options(
  tigris_use_cache = TRUE,                 # turn caching on
  tigris_class     = "sf"                  # always return sf objects
)

options(shiny.maxRequestSize = 50 * 1024^2)  # Set to 50MB or your desired limit

# Initialize reactive values
uploaded_data <- shiny::reactiveVal(NULL)
state <- shiny::reactiveVal(NULL)
tract_year <- shiny::reactiveVal(NULL)
tract_data <- shiny::reactiveVal(NULL)
asu_data <- shiny::reactiveVal(NULL)
asu_tracts <- shiny::reactiveVal(NULL)
asu_summary <- shiny::reactiveVal(NULL)
full_data <- shiny::reactiveVal(NULL)
full_data_reset <- shiny::reactiveVal()
selected_tracts <- shiny::reactiveVal(NULL)
edit_table <- shiny::reactiveVal(NULL)
edit_summary <- shiny::reactiveVal(NULL)
current_selection <- shiny::reactiveVal(NULL)

# New England Optional year selection logic
output$is_new_england <- shiny::reactive({
  if (is.null(state())) return(FALSE)
  
  # New England state FIPS codes
  new_england_fips <- c("09", "23", "25", "33", "44", "50")  # CT, ME, MA, NH, RI, VT
  
  state() %in% new_england_fips
})

# Make it available to the UI
shiny::outputOptions(output, "is_new_england", suspendWhenHidden = FALSE)

# Tract Hunter staged state -----------------------------------------
th_state <- shiny::reactiveVal(NULL)
th_tract_list <- shiny::reactiveVal(NULL)
th_bls_df <- shiny::reactiveVal(NULL)

map_data_dbg <- shiny::reactiveVal(NULL)   # container

highlighted_tracts <- shiny::reactiveVal(character(0))

# Load static data
excel_names <- c("record",
                 "geoid",
                 "st_fips",
                 "cnty_fips",
                 "tract_fips",
                 "name",
                 "tract_pop_dec",
                 "tract_pop_cur",
                 "tract_emp",
                 "tract_unemp",
                 "tract_urate",
                 "tract_urate_error",
                 "cnty_pop_dec",
                 "cnty_pop_cur",
                 "cnty_emp",
                 "cnty_unemp",
                 "cnty_urate",
                 "cnty_urate_error",
                 "pop_shr",
                 "emp_shr",
                 "unemp_shr",
                 "laus_primary",
                 "cnty_emp_ave",
                 "cnty_unemp_ave",
                 "tract_ASU_clf",
                 "tract_ASU_emp",
                 "tract_ASU_unemp",
                 "tract_ASU_urate")
```

# Data Initialization

## Controls {data-width="150"}

This screen allows you to import the BLS-provided ASU file, generally named like *NV_asu23.xlsx* which will be the only external data import step necessary. The script will read the file, extract the state and corresponding year, and standardize the column names to avoid annual updates to the script.

If the necessary data is not in columns **A through AB** within the Excel file, this process will not work correctly.

Once the file is loaded, a preview of the data will appear on the right, the state and year will display below, and the analyst may proceed to the next tab (Load Initial ASU).

Note: at this time, ASUbuildR assumes a state is using county-based census tracts.  If a state uses another geography such as NECTAs as the basis for its ASU tract file, this process will require some modification.

```{r}
shiny::fileInput("file", "Choose Excel File", accept = c(".xls", ".xlsx"))

shiny::textOutput("selected_state")

shiny::textOutput("selected_year")
```

## Output {data-width="850"}

```{r}
shiny::tableOutput("data_preview")

shiny::observeEvent(input$file, {
  shiny::req(input$file)
  df <- readxl::read_excel(input$file$datapath, range = "A2:AB25000", col_names = excel_names) |>
    dplyr::filter(!is.na(geoid)) |>
    dplyr::mutate(GEOID = stringr::str_remove(geoid, "14000US")) |>
    dplyr::select(GEOID,
           st_fips,
           cnty_fips,
           tract_fips,
           name,
           tract_pop_cur,
           tract_ASU_clf,
           tract_ASU_emp,
           tract_ASU_unemp,
           tract_ASU_urate)
  
  uploaded_data(df)
  
  uploaded_data() |>
    dplyr::pull(st_fips) |>
    unique() |>
    state()
  
  readxl::read_excel(input$file$datapath, range = "H1:H1", col_names = "year") |>
    dplyr::pull(year) |>
    stringr::str_remove("tract_pop") |>
    tract_year()
  
  output$data_preview <- shiny::renderTable({
    head(uploaded_data(),50)
  })
  
  output$selected_state <- shiny::renderText({
    paste0("Selected FIPS is: ", state())
  })
  
  output$selected_year <- shiny::renderText({
    paste0("Tract Population Year is: ", tract_year())
  })
})
```

# Load Initial ASU

## Controls {data-width="200"}

```{r}
# ---- algorithm picker -------------------------------------------------
shiny::radioButtons(
  inputId = "asu_algo",
  label   = "Choose algorithm",
  choices = c("Original"      = "orig",
              "Tract Hunter"  = "mine"),
  inline  = TRUE
)

# -----------------------------------------------------------------------
# main "Run" button (always visible)
shiny::div(style = "margin-top: 0.5rem;",
    shiny::actionButton(
      inputId = "process",
      label   = "Load tracts & initialise",
      class   = "btn-primary"
    )
)

# -----------------------------------------------------------------------
# extra Tract-Hunter controls (only when algo == 'mine')
shiny::conditionalPanel(
  condition = "input.asu_algo === 'mine'",
  shiny::tagList(
    shiny::hr(style = "margin: 0.8rem 0;"),
    shiny::div(
      class = "btn-group",           # keep them on one line
      style = "width: 100%;",
      shiny::actionButton("th_pass",    "Run Hunter",     class = "btn-secondary"),
      shiny::actionButton("th_combine", "Combine Groups",   class = "btn-secondary")
    )
  )
)

# ---- New England year override controls ------------------------------
shiny::conditionalPanel(
  condition = "output.is_new_england === true",
  shiny::tagList(
    shiny::hr(style = "margin: 0.8rem 0;"),
    shiny::h5("New England Year Selection"),
    shiny::radioButtons(
      inputId = "ne_year_choice",
      label   = "Choose tract year:",
      choices = list(
        "Use detected year (default)" = "detected",
        "Use 2021 (last NECTA year)"  = "2021"
      ),
      selected = "detected",
      inline = FALSE
    ),
    shiny::p(
      style = "font-size: 0.9em; color: #666;",
      "Note: 2021 is the last year NECTA-based tracts were available for New England states."
    )
  )
)

# ---- dynamic algorithm description -----------------------------------
output$algo_blurb <- shiny::renderUI({

  if (is.null(input$asu_algo) || input$asu_algo == "orig") {
    ## ───────── ORIGINAL METHOD ─────────
    shiny::HTML(
      "<p>
        This button will launch two processes, which will take up to 5&nbsp;minutes
        to complete. For smaller states, it may take under 15&nbsp;seconds.
      </p>
      <p>
        First, the application will download census shapefiles by tract for the
        appropriate state and year. Next, after combining the BLS file with these
        shapefiles, it will iteratively search for contiguous geographic regions
        until the combined unemployment rate in each region is as close to
        6.45 % as possible.
      </p>
      <p>
        When this process is complete, a map will appear to the right, and a
        summary of the created ASU regions will appear below. It is important to
        note these will still include areas that do not qualify as an independent
        ASU (there is no check for population), but it gives the analyst a
        starting place for analysis.
      </p>
      <p>
        Once this step is done, you may proceed to the next step.
      </p>"
    )

  } else {
    ## ───────── TRACT-HUNTER METHOD ─────────
    shiny::HTML(
      "<p><strong>Tract Hunter pipeline</strong></p>
       <p>Because Tract Hunter works in stages, the interface exposes those
          stages as separate buttons:</p>
       <ul>
         <li><em>Load tracts & initialise</em><br>
             ▸ downloads shapefiles, merges the BLS file, then runs the
             <strong>Seed + Expand</strong> step automatically.</li>
         <li><em>Run ASU Pass</em><br>
             ▸ performs the optimisation/trade pass that adds
             high-unemployment neighbours and drops low-unemployment ones until
             every ASU is as close as possible to the
             <code>6.45&nbsp;%</code> threshold.</li>
         <li><em>Combine Groups</em><br>
             ▸ merges adjacent ASUs that share a boundary, then performs a
             <em>second</em> optimisation pass so no eligible tract is left
             behind.</li>
       </ul>
       <p>You can stop after any step to inspect the map, or run the buttons
          in sequence for the full, automatic workflow.  Each step updates the
          colour map and the unemployment totals shown on the right.</p>"
    )
  }
})

shiny::uiOutput("algo_blurb")

shiny::htmlOutput("total_unemp")
shiny::tableOutput("asu")

shiny::observeEvent(input$process, {
  
  ## 0 · Basic checks ----------------------------------------------------
  shiny::req(uploaded_data(), state(), tract_year())

  # ADD THIS NEW CODE HERE:
  # Determine which year to use
  selected_year <- tract_year()  # default to detected year
  
  # Check if this is New England and user selected 2021
  state_val <- state()
  if (!is.null(state_val) && length(state_val) > 0) {
    new_england_fips <- c("09", "23", "25", "33", "44", "50")
    if (state_val %in% new_england_fips && 
        !is.null(input$ne_year_choice) && 
        input$ne_year_choice == "2021") {
      selected_year <- "2021"
    }
  }

  ## 1 · Wrap the whole long job in withProgress -------------------------
  shiny::withProgress(message = "Running ASU initialisation…", value = 0, {
    
    # Add force year = 2021 option for New England  # <-- you can remove this comment now

    ## 1a · Build tracts + neighbours (can take ~10–60 s the first time)
    shiny::incProgress(0.10, detail = "Downloading Census shapefiles…")
    
    # CHANGE THIS LINE FROM:
    # tract_list <- tigris::tracts(state = state(), year = tract_year()) |>
    # TO:
    tract_list <- tigris::tracts(state = state(), year = selected_year) |>
      dplyr::mutate(
        row_num    = dplyr::row_number(),
        continuous = sfdep::st_contiguity(geometry)
      )

    ## 1b · Merge the BLS data
    shiny::incProgress(0.05, detail = "Merging BLS unemployment data…")
    data_merge <- tract_list |>
      dplyr::left_join(uploaded_data(), by = "GEOID")

    # 2 · Run the chosen ASU algorithm ---------------------------------
    algo_choice <- shiny::isolate(input$asu_algo %||% "orig")
    
    join_flag <- isTRUE(input$join_touching)   # ← keep the flag you already built
    
    shiny::incProgress(0.05, detail = "Finding initial ASU seeds…")
    if (algo_choice == "orig") {
      res <- run_asu_original(tract_list, uploaded_data())
    } else {
      shiny::withProgress(message = "Seeding & expanding…", value = 0, {
        th_tract_list(tract_list)
        th_bls_df(uploaded_data())
        st <- tract_hunter_seed(th_tract_list(), th_bls_df(), verbose = TRUE)})
      th_state(st)
      res <- tract_hunter_finalize(st)
    }

    ## 3 · Finish the bar
    shiny::incProgress(1, detail = "Finishing up…")
  })  # ---- withProgress ends here  -------------------------------------

  ## 4 · Store results & draw map  --------------------------------------
  if (!is.null(res)) {
    full_data(res$full_data  )   ; full_data_reset(res$full_data_reset)
    asu_data(res$asu_data    )   ; asu_tracts(res$asu_tracts)
    asu_summary(res$asu_summary) ; map_data_dbg(res$full_data)

    output$asu <- shiny::renderTable( asu_summary(),digits = 3 )

    ## 5. (Re‑)draw the first map ----------------------------------

  output$initial_map <- mapgl::renderMaplibre({

    shiny::req(full_data())
    map_data <- full_data()

    # ---- 6·1 geometry housekeeping ----------------------------------
    map_data <- map_data |>
      sf::st_make_valid() |>
      sf::st_zm(what = "ZM", drop = TRUE) |>
      dplyr::filter(!sf::st_is_empty(geometry)) |>
      dplyr::mutate(geom_type = sf::st_geometry_type(geometry)) |>
      dplyr::filter(geom_type %in% c("POLYGON", "MULTIPOLYGON")) |>
      dplyr::select(-geom_type)

    if (nrow(map_data) == 0) {
      return(
        mapgl::maplibre(style = mapgl::carto_style("positron")) |>
        mapgl::add_control("No valid polygon geometry to display.", "top-left")
      )
    }

    # ---- 6·2 palette / breaks ---------------------------------------
    map_data <- map_data |>
      dplyr::mutate(asunum = dplyr::na_if(asunum, 0L))

    n_asu <- max(map_data$asunum, na.rm = TRUE)
    n_asu <- ifelse(is.finite(n_asu), n_asu, 0L)

    palette_logic <- function(n_asu) {
  if (n_asu == 0) {
    list(fill = "#808080",
         legend_vals = "(none)",
         legend_cols = "#808080")

  } else if (n_asu == 1) {
    list(
      fill  = mapgl::step_expr(column="asunum",
                        base="#808080",
                        stops="#7FC97F",
                        values=1,
                        na_color="#444444"),
      legend_vals = 1,
      legend_cols = "#7FC97F"
    )

  } else {
    n_cat <- min(max(n_asu, 3L), 8L)          # 3-to-8 distinct hues
    pal   <- RColorBrewer::brewer.pal(n_cat, "Accent")

    # make colours exactly as long as the value vector
    legend_cols <- rep_len(pal, n_asu)

    breaks <- seq(1 + n_asu / n_cat, n_asu, length.out = n_cat - 1)

    list(
      fill = mapgl::step_expr(column   = "asunum",
                       base     = pal[1],
                       stops    = pal[-1],
                       values   = breaks,
                       na_color = "#444444"),
      legend_vals = seq_len(n_asu),
      legend_cols = legend_cols
    )
  }
}

    pal <- palette_logic(n_asu)

    # ---- 6·3 build map ----------------------------------------------
    mapgl::maplibre(style = mapgl::carto_style("positron")) |>
      mapgl::fit_bounds(map_data, animate = FALSE) |>
      mapgl::add_fill_layer(
        id                 = "basemap",
        source             = map_data,
        fill_color         = pal$fill,
        fill_opacity       = 0.5,
        fill_outline_color = "black",
        tooltip = mapgl::concat(
          "<strong>ASU Number: </strong>", mapgl::get_column("asunum"), "<br>",
          "<strong>Tract GEOID: </strong>", mapgl::get_column("GEOID"),  "<br>",
          "<strong>UR: </strong>",
          mapgl::number_format(mapgl::get_column("tract_ASU_urate"),
                        style = "decimal", maximum_fraction_digits = 2),
          "%<br>",
          "<strong>Unemp: </strong>",
          mapgl::number_format(mapgl::get_column("tract_ASU_unemp"),
                        style = "decimal", maximum_fraction_digits = 0), "<br>"
        )
      ) |>
      mapgl::add_legend(
        "ASU Number",
        values = pal$legend_vals,
        colors = pal$legend_cols,
        type   = "categorical"
      )
  })

}

})  # ---- end observeEvent -------------------------------------------------

shiny::observeEvent(input$th_pass, {
  shiny::req(th_state())
  shiny::withProgress(message = "Running ASU pass…", value = 0, {
    st <- tract_hunter_asu_pass(th_state(), verbose = TRUE)
  })
  th_state(st)
  res <- tract_hunter_finalize(st)
  full_data(res$full_data  )   ; full_data_reset(res$full_data_reset)
  asu_data(res$asu_data    )   ; asu_tracts(res$asu_tracts)
  asu_summary(res$asu_summary) ; map_data_dbg(res$full_data)
  output$asu <- shiny::renderTable( asu_summary(),digits = 3 )
  mapgl::maplibre_proxy("initial_map") |> mapgl::clear_layer("basemap")
  output$initial_map <- mapgl::renderMaplibre({
    shiny::req(full_data())
    map_data <- full_data()
    map_data <- map_data |>
      sf::st_make_valid() |>
      sf::st_zm(what = "ZM", drop = TRUE) |>
      dplyr::filter(!sf::st_is_empty(geometry)) |>
      dplyr::mutate(geom_type = sf::st_geometry_type(geometry)) |>
      dplyr::filter(geom_type %in% c("POLYGON", "MULTIPOLYGON")) |>
      dplyr::select(-geom_type)
    if (nrow(map_data) == 0) {
      return(
        mapgl::maplibre(style = mapgl::carto_style("positron")) |>
        mapgl::add_control("No valid polygon geometry to display.", "top-left")
      )
    }
    map_data <- map_data |>
      dplyr::mutate(asunum = dplyr::na_if(asunum, 0L))
    n_asu <- max(map_data$asunum, na.rm = TRUE)
    n_asu <- ifelse(is.finite(n_asu), n_asu, 0L)
    
    palette_logic <- function(n_asu) {
  if (n_asu == 0) {
    list(fill = "#808080",
         legend_vals = "(none)",
         legend_cols = "#808080")

  } else if (n_asu == 1) {
    list(
      fill  = mapgl::step_expr(column="asunum",
                        base="#808080",
                        stops="#7FC97F",
                        values=1,
                        na_color="#444444"),
      legend_vals = 1,
      legend_cols = "#7FC97F"
    )

  } else {
    n_cat <- min(max(n_asu, 3L), 8L)          # 3-to-8 distinct hues
    pal   <- RColorBrewer::brewer.pal(n_cat, "Accent")

    # make colours exactly as long as the value vector
    legend_cols <- rep_len(pal, n_asu)

    breaks <- seq(1 + n_asu / n_cat, n_asu, length.out = n_cat - 1)

    list(
      fill = mapgl::step_expr(column   = "asunum",
                       base     = pal[1],
                       stops    = pal[-1],
                       values   = breaks,
                       na_color = "#444444"),
      legend_vals = seq_len(n_asu),
      legend_cols = legend_cols
    )
  }
}
    
    pal <- palette_logic(n_asu)
    mapgl::maplibre(style = mapgl::carto_style("positron")) |>
      mapgl::fit_bounds(map_data, animate = FALSE) |>
      mapgl::add_fill_layer(
        id                 = "basemap",
        source             = map_data,
        fill_color         = pal$fill,
        fill_opacity       = 0.5,
        fill_outline_color = "black"
      )
  })
})

shiny::observeEvent(input$th_combine, {
  shiny::req(th_state())
  shiny::withProgress(message = "Combining ASUs…", value = 0, {
    st <- tract_hunter_combine_groups(th_state())
  })
  th_state(st)
  res <- tract_hunter_finalize(st)
  full_data(res$full_data  )   ; full_data_reset(res$full_data_reset)
  asu_data(res$asu_data    )   ; asu_tracts(res$asu_tracts)
  asu_summary(res$asu_summary) ; map_data_dbg(res$full_data)
  output$asu <- shiny::renderTable( asu_summary(),digits = 3 )
  mapgl::maplibre_proxy("initial_map") |> mapgl::clear_layer("basemap")
  output$initial_map <- mapgl::renderMaplibre({
    shiny::req(full_data())
    map_data <- full_data()
    map_data <- map_data |>
      sf::st_make_valid() |>
      sf::st_zm(what = "ZM", drop = TRUE) |>
      dplyr::filter(!sf::st_is_empty(geometry)) |>
      dplyr::mutate(geom_type = sf::st_geometry_type(geometry)) |>
      dplyr::filter(geom_type %in% c("POLYGON", "MULTIPOLYGON")) |>
      dplyr::select(-geom_type)
    if (nrow(map_data) == 0) {
      return(
        mapgl::maplibre(style = mapgl::carto_style("positron")) |>
        mapgl::add_control("No valid polygon geometry to display.", "top-left")
      )
    }
    map_data <- map_data |>
      dplyr::mutate(asunum = dplyr::na_if(asunum, 0L))
    n_asu <- max(map_data$asunum, na.rm = TRUE)
    n_asu <- ifelse(is.finite(n_asu), n_asu, 0L)
    
    palette_logic <- function(n_asu) {
  if (n_asu == 0) {
    list(fill = "#808080",
         legend_vals = "(none)",
         legend_cols = "#808080")

  } else if (n_asu == 1) {
    list(
      fill  = mapgl::step_expr(column="asunum",
                        base="#808080",
                        stops="#7FC97F",
                        values=1,
                        na_color="#444444"),
      legend_vals = 1,
      legend_cols = "#7FC97F"
    )

  } else {
    n_cat <- min(max(n_asu, 3L), 8L)          # 3-to-8 distinct hues
    pal   <- RColorBrewer::brewer.pal(n_cat, "Accent")

    # make colours exactly as long as the value vector
    legend_cols <- rep_len(pal, n_asu)

    breaks <- seq(1 + n_asu / n_cat, n_asu, length.out = n_cat - 1)

    list(
      fill = mapgl::step_expr(column   = "asunum",
                       base     = pal[1],
                       stops    = pal[-1],
                       values   = breaks,
                       na_color = "#444444"),
      legend_vals = seq_len(n_asu),
      legend_cols = legend_cols
    )
  }
}
    
    pal <- palette_logic(n_asu)
    mapgl::maplibre(style = mapgl::carto_style("positron")) |>
      mapgl::fit_bounds(map_data, animate = FALSE) |>
      mapgl::add_fill_layer(
        id                 = "basemap",
        source             = map_data,
        fill_color         = pal$fill,
        fill_opacity       = 0.5,
        fill_outline_color = "black"
      )
  })
})

#-------Total Unemployment Box --------------------------------
total_unemp <- shiny::reactive({
  shiny::req(full_data())                                  # wait until available
  full_data() |>
    dplyr::filter(asunum > 0) |>
    dplyr::summarise(unemp = sum(tract_ASU_unemp, na.rm = TRUE)) |>
    dplyr::pull(unemp)
})

output$total_unemp <- shiny::renderUI({
  shiny::HTML(
    paste0("<strong>Total Unemployment in ASUs:</strong> ",
           scales::comma(total_unemp()))
  )
})
```

## Output {data-width="800"}

```{r}
mapgl::maplibreOutput("initial_map", height = "100vh")
```

# Modify ASU Selections

## Controls {data-width="150" style="height: 100vh; overflow-y: auto; padding-right: 10px;"}

These tools allow you to select, inspect, and change ASU designations for individual Census tracts.  *Selected* Census tracts will be outlined in red, and are the tracts updated when you change the ASU number.  You may also click on the map to select or unselect individual tracts. An ASU value of 0 means the tract is not included in any ASU.

```{r}
# Select an ASU
asu_selection_ui <- shiny::reactive({
  shiny::selectInput("select_asunum", "Select ASU Number:",
              choices = c("None", asu_choices()),
              selected = "None")
})
shiny::renderUI(asu_selection_ui())
shiny::renderUI(shiny::HTML("<hr>"))

# Change ASU
shiny::numericInput("new_asu", "Change ASU Value:", value = 0, min = 0)
shiny::actionButton("update", "Update Selected Tracts")
shiny::renderUI(shiny::HTML("<hr>"))

# Clear Selected Tracts
shiny::actionButton("clear", "Clear Selected Tracts")
shiny::renderUI(shiny::HTML("<hr>"))

# Show Data for Selection
shiny::actionButton("preview", "Show Data for Selected Tracts")
asu_choices <- shiny::reactive({
  shiny::req(full_data())                     # only run after full_data exists
  full_data() |> dplyr::pull(asunum) |> unique() |> sort()
})

shiny::renderUI(shiny::HTML("<hr>"))

# Show Lowest UR Tracts in Selection
shiny::selectInput("unemployment_filter", 
             "Highlight selected tracts with:",
             choices = list("Low unemployment" = "low", 
                           "High unemployment" = "high"),
             selected = "low")
shiny::numericInput("percentile", "Percentile Threshold:", value = 5, min = 1, max = 100, step = 1)
shiny::actionButton("filter_percentile", "Highlight Tracts")
shiny::actionButton("clear_percentile", "Clear Highlights")
shiny::renderUI(shiny::HTML("<hr>"))

# Single GROID Selection
shiny::textInput("manual_geoid", "Enter a GEOID:", placeholder = "32031990000")
shiny::actionButton("select_geoid", "Select a Single Tract")
shiny::renderUI(shiny::HTML("<hr>"))

# Reset to Initial Load
shiny::actionButton("reset", "Reset to Initial Data")
```

## Output {data-width="850"}

```{r}
mapgl::maplibreOutput("edit_map", height = "90vh")

shiny::tableOutput("selection_data")

shiny::tableOutput("selection_summary")

output$edit_map <- mapgl::renderMaplibre({
  
  shiny::req(full_data())
  
  number_asus <- max(full_data()$asunum)
  number_categories <- min(c(number_asus, 8))
  asu_per_category <- number_asus/number_categories
  
  # Create breaks for ASU categories, excluding 0
  if (number_categories == 1) {
    # Single ASU: just need one break at 1
    asu_breaks <- 1
    actual_categories <- 1
    brewer_pal <- "#7FC97F"  # Single color
  } else {
    # Multiple ASUs: create breaks from 1 to max, evenly spaced
    asu_breaks <- seq(from = 1, to = number_asus, length.out = number_categories)
    actual_categories <- max(3, number_categories)  # Ensure minimum of 3 for brewer.pal
    full_brewer_pal <- RColorBrewer::brewer.pal(actual_categories, "Accent")
    brewer_pal <- full_brewer_pal[1:number_categories]  # Take only what we need
  }

  mapgl::maplibre(style = mapgl::carto_style("positron")) |>
    mapgl::fit_bounds(full_data(), animate = FALSE) |> 
    mapgl::add_fill_layer(
      id = "basemap",
      source = full_data(),
      fill_color = mapgl::step_expr(
        column = "asunum",
        base = "#808080",  # Grey for asunum == 0 (and anything < first break)
        stops = brewer_pal,
        values = asu_breaks,
        na_color = "#444444"
      ),
      fill_opacity = 0.5,
      fill_outline_color = "black",
      tooltip = mapgl::concat(
        "<strong>ASU Number: </strong>",mapgl::get_column("asunum"), "<br>",
        "<strong>Tract GEOID: </strong>",mapgl::get_column("GEOID"),"<br>",
        "<strong>Tract Population: </strong>",mapgl::number_format(mapgl::get_column("tract_pop_cur"), style = "decimal", maximum_fraction_digits = 0),"<br>",
                "<strong>Tract Labor Force: </strong>",mapgl::number_format(mapgl::get_column("tract_ASU_clf"), style = "decimal", maximum_fraction_digits = 0),"<br>",
        "<strong>Tract Unemployment Rate: </strong>",mapgl::number_format(mapgl::get_column("tract_ASU_urate"), style = "decimal", maximum_fraction_digits = 2),"%<br>",
        "<strong>Tract Unemployment: </strong>",mapgl::number_format(mapgl::get_column("tract_ASU_unemp"), style = "decimal", maximum_fraction_digits = 0),"<br>")
    )
})

# Select or Unselect tracts on click
shiny::observeEvent(input$edit_map_feature_click, {
  click <- input$edit_map_feature_click
  current_selection <- selected_tracts()
  
  # Extract the GEOID from the clicked feature properties
  clicked_geoid <- click$properties$GEOID
  
  # Check if clicked_geoid is not NULL and not empty
  if (is.null(clicked_geoid) || length(clicked_geoid) == 0 || is.na(clicked_geoid)) {
    return()  # Exit early if no valid GEOID
  }
  
  # Add or remove the selected tract
  if (clicked_geoid %in% current_selection) {
    current_selection <- setdiff(current_selection, clicked_geoid)
  } else {
    current_selection <- c(current_selection, clicked_geoid)
  }
  
  selected_tracts(current_selection)
  
  # Update the map highlighting
  if (length(current_selection) > 0) {
    selected_data <- subset(full_data(), GEOID %in% selected_tracts())
    
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::clear_layer("selected") |>
      mapgl::add_line_layer(
        id = "selected",
        source = selected_data,
        line_color = "red",
        line_width = 3,
        line_opacity = 1
      )
  } else {
    # Clear the selection layer if no tracts are selected
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::clear_layer("selected")
  }
  
  # Update the selection table
  output$selection_table <- shiny::renderTable({
    selected_tracts()
  }, digits = 3)
})

# Clear Selected Tracts on Button Click
shiny::observeEvent(input$clear, {
  
  selected_tracts(NULL)
  
  # Update the map highlighting
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::clear_layer("selected")
    return()
})

# Select tracts in an ASU from dropdown
shiny::observeEvent(input$select_asunum, {
  shiny::req(full_data())
  
  # Skip if "None" is selected
  if (input$select_asunum == "None") {
    selected_tracts(NULL)
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::clear_layer("selected")
    return()
  }
  
  # Get all tracts with the selected ASU number
  selected_tract_ids <- full_data() |>
    dplyr::filter(asunum == as.numeric(input$select_asunum)) |>
    dplyr::pull(GEOID)
  
  # Update the selected_tracts reactive value
  selected_tracts(selected_tract_ids)
  
  # Get the filtered data for selected tracts
  selected_data <- subset(full_data(), GEOID %in% selected_tract_ids)
  
  # Highlight the selected tracts on the map using maplibre proxy
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::clear_layer("selected") |>
    mapgl::add_line_layer(
      id = "selected",
      source = selected_data,
      line_color = "red",
      line_width = 3,
      line_opacity = 1
    ) |> 
    mapgl::fit_bounds(selected_data, animate = TRUE)
})

# Select a single tract given a GEOID
shiny::observeEvent(input$select_geoid, {
  shiny::req(full_data())
  
  # Get the selected tract's data
  selected_tract <- full_data() |>
    dplyr::filter(GEOID == input$manual_geoid)
  
  # If the tract exists, highlight it and fit bounds
  if (nrow(selected_tract) > 0) {
    # Highlight the selected tract on the map using maplibre proxy
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::clear_layer("selected") |>
      mapgl::add_line_layer(
        id = "selected",
        source = selected_tract,
        line_color = "red",
        line_width = 3,
        line_opacity = 1
      ) |>
      mapgl::fit_bounds(selected_tract, animate = TRUE)
    
    # Update the selected_tracts reactive value
    selected_tracts(selected_tract$GEOID)
  }
})

# Create a reactive expression that handles the filtering logic
filtered_tracts <- shiny::reactive({
  shiny::req(input$percentile, input$unemployment_filter, full_data(), selected_tracts())
  
  potential_lighlights <- full_data() |>
    dplyr::filter(GEOID %in% selected_tracts(),
           tract_pop_cur > 0)
  
  if (input$unemployment_filter == "low") {
    
    threshold <- stats::quantile(potential_lighlights$tract_ASU_urate, input$percentile/100)
    
    filtered_selected <- potential_lighlights |>
      dplyr::filter(tract_ASU_urate <= threshold,
             tract_ASU_urate > 0) |>
      dplyr::pull(GEOID)
  } else {
    
    threshold <- stats::quantile(potential_lighlights$tract_ASU_urate, 1-(input$percentile/100))
    
    filtered_selected <- potential_lighlights |>
      dplyr::filter(tract_ASU_urate >= threshold,
             tract_ASU_urate > 0) |>
      dplyr::pull(GEOID)
  }
  
  return(filtered_selected)
})

# Single observer that responds to changes in either input
shiny::observeEvent(list(input$filter_percentile, input$unemployment_filter), {
  
  filtered_selected <- filtered_tracts()
  highlighted_tracts(filtered_selected)
  
  filtered_data <- subset(full_data(), GEOID %in% filtered_selected)
  
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::clear_layer("highlighted") |>
    mapgl::add_fill_layer(
      id = "highlighted",
      source = filtered_data,
      fill_color = "black",
      fill_opacity = 0.8
    )
})

# Clear highlights with button click or when changing ASU selection
shiny::observeEvent(list(input$clear_percentile, input$select_asunum), {
  
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::clear_layer("highlighted")
  
})

# Calculate and display a table of data for selected tracts
shiny::observeEvent(input$preview, {
  shiny::req(selected_tracts())

  replacement_data <- full_data() |>
    sf::st_drop_geometry() |>
    subset(GEOID %in% selected_tracts())

  edit_table(replacement_data)

  edit_table() |>
    dplyr::ungroup() |>
    dplyr::summarize(
      tracts = dplyr::n(),
      population = sum(tract_pop_cur, na.rm = TRUE),
      lf = sum(tract_ASU_clf, na.rm = TRUE),
      unemp = sum(tract_ASU_unemp, na.rm = TRUE),
      ur = round(unemp/lf*100, 5)
    ) |>
    edit_summary()

  # Show Preview of Selected Tracts
  output$selection_summary <- shiny::renderTable({
    edit_summary()
  })
})

# Update selected tracts to new ASU number.
shiny::observeEvent(input$update, {
  shiny::req(selected_tracts(), full_data())
  
  # Update the full_data reactive value
  updated_data <- full_data() |>
    dplyr::filter(GEOID %in% selected_tracts()) |>
    dplyr::mutate(asunum = as.numeric(input$new_asu)) |>
    rbind(
      full_data() |>
        dplyr::filter(!(GEOID %in% selected_tracts()))
    )
  
  # Update the reactive value
  full_data(updated_data)
  
  # Clear selected tracts
  selected_tracts(NULL)
  
  # Update map to remove highlight on selected tracts
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::clear_layer("selected")
})

# Reset data to initial data load from Excel input
shiny::observeEvent(input$reset, {
  shiny::req(full_data_reset(), full_data())
  
  # Reset the full_data reactive value
  full_data(full_data_reset())
  
  # Clear selected tracts
  selected_tracts(NULL)
  
  # Update map to remove highlight on selected tracts
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::clear_layer("selected")
})

# OPTIMIZATION 7: Periodic cleanup for long sessions
shiny::observe({
  shiny::invalidateLater(60000)  # Every minute
  if (exists("gc")) gc()  # Clean up memory
}) |> 
shiny::bindEvent(input$update, ignoreInit = TRUE)
```

# Save and Load Data

## Controls {data-width="150"}

These buttons allow you to save the map in progress so that you can load
it again in the future to continue your work.

First, choose a save directory. The default is your current working
directory. After loading data, you can go directly to the ASU
Modification tab to continue making edits.

```{r}
# Directory selection - Simple text input approach
shiny::textInput("save_dir_path", "Save Directory Path:", value = getwd(), width = "100%")
shiny::br()
shiny::actionButton("browse_dir", "Browse for Directory")
shiny::br()
shiny::br()
shiny::textOutput("current_save_dir")
shiny::textOutput("dir_status")
shiny::br()

shiny::actionButton("save_data", "Save Data")
shiny::fileInput("load_data", "Load Data", accept = c(".rds"))

# Reactive value to store the selected directory
save_directory <- shiny::reactiveVal(getwd())  # Default to current working directory

# Observer to handle directory path changes
shiny::observeEvent(input$save_dir_path, {
  if (!is.null(input$save_dir_path) && input$save_dir_path != "") {
    if (dir.exists(input$save_dir_path)) {
      save_directory(input$save_dir_path)
    }
  }
})

# Alternative browse button (opens file dialog for directory selection)
shiny::observeEvent(input$browse_dir, {
  # This will work in RStudio or desktop R
  if (interactive()) {
    selected_dir <- tryCatch({
      utils::choose.dir(default = save_directory(), caption = "Select Save Directory")
    }, error = function(e) {
      # For non-Windows systems, use tcltk
      tryCatch({
        tcltk::tk_choose.dir(default = save_directory(), caption = "Select Save Directory")
      }, error = function(e2) {
        NULL
      })
    })
    
    if (!is.null(selected_dir) && selected_dir != "") {
      shiny::updateTextInput(session, "save_dir_path", value = selected_dir)
      save_directory(selected_dir)
    }
  } else {
    # In web-deployed apps, show instruction
    shiny::showModal(shiny::modalDialog(
      title = "Directory Selection",
      "In web-deployed apps, please manually enter the directory path in the text field above.",
      easyClose = TRUE
    ))
  }
})

# Display current save directory
output$current_save_dir <- shiny::renderText({
  paste("Current save directory: ", save_directory())
})

# Display directory status
output$dir_status <- shiny::renderText({
  if (dir.exists(save_directory())) {
    "✓ Directory exists and is accessible"
  } else {
    "⚠ Directory does not exist - it will be created when saving"
  }
})

# Observer for saving the data
shiny::observeEvent(input$save_data, {
  shiny::req(full_data())
  
  # Use the selected directory
  save_path <- file.path(save_directory(), "saved_data.rds")
  
  # Check if directory exists, create if it doesn't
  if (!dir.exists(save_directory())) {
    dir.create(save_directory(), recursive = TRUE)
  }
  
  # Save the full_data object to an RDS file
  tryCatch({
    saveRDS(full_data(), save_path)
    
    # Provide feedback to the user
    shiny::showModal(shiny::modalDialog(
      title = "Data Saved",
      paste("Your data has been saved to:", save_path),
      easyClose = TRUE
    ))
  }, error = function(e) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Saving Data",
      paste("Failed to save data:", e$message),
      easyClose = TRUE
    ))
  })
})

# Observer for loading the data
shiny::observeEvent(input$load_data, {
  shiny::req(input$load_data)
  
  # Read the RDS file into a data frame
  loaded_data <- tryCatch({
    readRDS(input$load_data$datapath)
  }, error = function(e) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Loading Data",
      "Failed to load the data. Please check the file format.",
      easyClose = TRUE
    ))
    return(NULL)
  })
  
  # If loaded_data is NULL (failed to load), exit the observer
  shiny::req(!is.null(loaded_data))
  
  # Ensure the loaded data is an sf object
  if (!inherits(loaded_data, "sf")) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Loading Data",
      "The loaded data is not a valid sf object.",
      easyClose = TRUE
    ))
    return(NULL)
  }
  
  # Update full_data with the loaded data
  full_data(loaded_data)
  
  # Provide feedback to the user
  shiny::showModal(shiny::modalDialog(
    title = "Data Loaded",
    "Your data has been successfully loaded.",
    easyClose = TRUE
  ))
  
  # Recreate the color scheme logic (same as in renderMaplibre)
  number_asus <- max(full_data()$asunum)
  number_categories <- min(c(number_asus, 8))
  asu_per_category <- number_asus/number_categories
  
  # Create breaks for ASU categories, excluding 0
  if (number_categories == 1) {
    # Single ASU: just need one break at 1
    asu_breaks <- 1
    actual_categories <- 1
    brewer_pal <- "#7FC97F"  # Single color
  } else {
    # Multiple ASUs: create breaks from 1 to max, evenly spaced
    asu_breaks <- seq(from = 1, to = number_asus, length.out = number_categories)
    actual_categories <- max(3, number_categories)  # Ensure minimum of 3 for brewer.pal
    full_brewer_pal <- RColorBrewer::brewer.pal(actual_categories, "Accent")
    brewer_pal <- full_brewer_pal[1:number_categories]  # Take only what we need
  }
  
  # Update the map using maplibre_proxy
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::clear_layer("basemap") |>
    mapgl::add_fill_layer(
      id = "basemap",
      source = full_data(),
      fill_color = mapgl::step_expr(
        column = "asunum",
        base = "#808080",  # Grey for asunum == 0 (and anything < first break)
        stops = brewer_pal,
        values = asu_breaks,
        na_color = "#444444"
      ),
      fill_opacity = 0.5,
      fill_outline_color = "black",
      tooltip = mapgl::concat(
        "<strong>ASU Number: </strong>", mapgl::get_column("asunum"), "<br>",
        "<strong>Tract GEOID: </strong>", mapgl::get_column("GEOID"), "<br>",
        "<strong>Tract Unemployment Rate: </strong>", mapgl::number_format(mapgl::get_column("tract_ASU_urate"), style = "decimal", maximum_fraction_digits = 2), "%<br>",
        "<strong>Tract Unemployment: </strong>", mapgl::number_format(mapgl::get_column("tract_ASU_unemp"), style = "decimal", maximum_fraction_digits = 0), "<br>"
      )
    ) |>
    mapgl::fit_bounds(full_data(), animate = TRUE)
})
```

## Output {data-width="850"}

```{r}
# Empty output section
```

# ASU Review and Finalization

## Controls {data-width="150"}

This screen will allow you to review your selected ASUs. It uses a
threshold of 6.45% unemployment and a population of 10,000, but these
numbers can be modified in case they change in the future.

*Generate ASU Summary* will show a table of all ASUs, and whether they
pass or fail the ASU definitions for unemployment and population. Please
pay attention to these measures - an unemployment rate of 6.449% will
display as 6.45%, but will fail the validation.

Note, you *may* go back and forth between the selection and review
screens.

When ready to create an output file, the *Generate LSS .txt File* button
will create a formatted batch file for upload to LSS.

```{r}
shiny::numericInput("asu_ur", "ASU Unemployment Rate Threshold:", value = 6.45, min = 0)

shiny::numericInput("asu_pop", "ASU Population Threshold:", value = 10000, min = 0)

shiny::actionButton("run_asu_summary", "Generate ASU Summary")
shiny::renderUI(shiny::HTML("<hr>"))

shiny::textOutput("current_save_dir")
shiny::renderUI(shiny::HTML("<hr>"))

shiny::actionButton("lss_txt", "Generate LSS .txt File")
shiny::renderUI(shiny::HTML("<hr>"))

shiny::actionButton("review_txt", "Create Summary CSV")
```

## Output {data-width="850"}

```{r}
shiny::tableOutput("asu_review")

summarized_asu <- shiny::reactiveVal(NULL)

shiny::observeEvent(input$run_asu_summary, {
  
  shiny::req(full_data())
  
  summary_table <- full_data() |>
    sf::st_drop_geometry() |>
    dplyr::group_by(asunum) |>
    dplyr::filter(asunum > 0.5) |>
    dplyr::summarize(
      Tracts = dplyr::n(),
      Population = sum(tract_pop_cur, na.rm = TRUE),
      `Labor Force` = sum(tract_ASU_clf, na.rm = TRUE),
      Unemployment = sum(tract_ASU_unemp, na.rm = TRUE),
      `Unemployment Rate` = round(Unemployment/`Labor Force`*100, 5)
    ) |>
    dplyr::ungroup() |>
    dplyr::mutate(
      ur_qualified = dplyr::if_else(`Unemployment Rate` >= input$asu_ur, TRUE, FALSE),
      pop_qualified = dplyr::if_else(Population >= input$asu_pop, TRUE, FALSE),
      asu_qualified = ur_qualified & pop_qualified
    )
  
  summarized_asu(summary_table)
})

output$asu_review <- shiny::renderTable({
  summarized_asu()
})

shiny::observeEvent(input$lss_txt, {
  
  shiny::req(full_data())

  # Function to generate text content
  generate_txt <- function() {
    df <- full_data() |>
      sf::st_drop_geometry() |>
      dplyr::select(GEOID, asunum) |>
      dplyr::filter(asunum > 0) |>
      dplyr::mutate(asunum = as.integer(asunum),
             GEOID = paste0("14000US", GEOID),
             asunum = paste0("SU", state(), sprintf("%04d", asunum)),
             GEOID = paste(asunum, GEOID, sep = " + ")) |> 
      dplyr::arrange(asunum, GEOID) |>
      dplyr::select(-asunum)

    txt_content <- utils::capture.output(utils::write.table(df, quote=FALSE, row.names=FALSE, col.names = FALSE))
    txt_content <- paste(txt_content, collapse="\n")
    return(txt_content)
  }

  # Get the current save directory from the reactive value
  current_dir <- save_directory()
  
  # Validate directory path
  if (is.null(current_dir) || current_dir == "") {
    shiny::showModal(shiny::modalDialog(
      title = "No Directory Selected",
      "Please select a save directory first in the Save and Load Data tab.",
      easyClose = TRUE
    ))
    return()
  }

  # Create the content
  txt_content <- generate_txt()

  # Use the selected save directory
  filePath <- file.path(current_dir, "lss_batch_file.txt")
  
  # Ensure directory exists
  if (!dir.exists(current_dir)) {
    tryCatch({
      dir.create(current_dir, recursive = TRUE)
    }, error = function(e) {
      shiny::showModal(shiny::modalDialog(
        title = "Directory Error",
        paste("Cannot create directory:", current_dir, "\nError:", e$message),
        easyClose = TRUE
      ))
      return()
    })
  }
  
  tryCatch({
    # Write the file
    writeLines(txt_content, filePath)
    
    # Show success message with file location
    shiny::showModal(shiny::modalDialog(
      title = "File Created Successfully",
      shiny::HTML(paste0(
        "<strong>LSS batch file has been saved to:</strong><br>",
        "<code>", filePath, "</code>"
      )),
      easyClose = TRUE
    ))
    
  }, error = function(e) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Creating File",
      paste("Failed to create LSS file:", e$message),
      easyClose = TRUE
    ))
  })
})

shiny::observeEvent(input$review_txt, {

  shiny::req(full_data())

  # Function to generate CSV content
  generate_csv <- function() {
    df <- full_data() |>
      sf::st_drop_geometry() |>
      dplyr::arrange(asunum, GEOID)
    
    return(df)
  }
  
  # Get the current save directory from the reactive value
  current_dir <- save_directory()
  
  # Validate directory path
  if (is.null(current_dir) || current_dir == "") {
    shiny::showModal(shiny::modalDialog(
      title = "No Directory Selected",
      "Please select a save directory first in the Save and Load Data tab.",
      easyClose = TRUE
    ))
    return()
  }

  # Create the content
  df <- generate_csv()

  # Use the selected save directory
  filePath <- file.path(current_dir, "ASU_Review_File.csv")
  
  # Ensure directory exists
  if (!dir.exists(current_dir)) {
    tryCatch({
      dir.create(current_dir, recursive = TRUE)
    }, error = function(e) {
      shiny::showModal(shiny::modalDialog(
        title = "Directory Error",
        paste("Cannot create directory:", current_dir, "\nError:", e$message),
        easyClose = TRUE
      ))
      return()
    })
  }
  
  tryCatch({
    # Write the CSV file
    utils::write.csv(df, filePath, row.names = FALSE)
    
    # Show success message with file location
    shiny::showModal(shiny::modalDialog(
      title = "File Created Successfully",
      shiny::HTML(paste0(
        "<strong>ASU Review CSV has been saved to:</strong><br>",
        "<code>", filePath, "</code>"
      )),
      easyClose = TRUE
    ))
    
  }, error = function(e) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Creating File",
      paste("Failed to create CSV file:", e$message),
      easyClose = TRUE
    ))
  })
})

####################
## Future Development

# Export Excel Worksheet with tract details and selections.
# Allow "Save" of data with txt/Excel files so single session is not required.
# Better table formatting.
# highlight high unemployment tracts in non-included areas.
# Check for contiguity of selected ASUs after manual edits.
# Export high-resolution images of ASUs for review.
# Use reactlog package to monitor reactive interactions in the code for cleanup. https://mastering-shiny.org/reactive-graph.html
```


# How to Use ASUbuildR

**About ASUloadR**

ASUloadR is an application built in R using Shiny and Flexdashboard to
create a point-and-click environment to build Areas of Substantial
Unemployment (ASU). While this package does not replace the work of an
analyst in a state from working on the ASU process, it provides tools to
make that process more straightforward.

It should be noted, the U.S. Bureau of Labor Statistics has several
options for designating ASUs. **ASUloadR** only uses the addition
method, building regions at the Census Tract level. Analysts may
discover that other alternatives work better for their state in a given
year.

The ASU creation logic in this program was created by a collaboration
between the states of Ohio and Nevada, with the Shiny app and Graphical
User Interface designed by Nevada’s Research & Analysis Bureau.

The Github repository for this package can be found at
<https://github.com/schmidtDETR/ASUbuildR>

**About the ASU Process**

The ASU process typically begins when the U.S. Bureau of Labor
Statistics distributes to each state a file providing the calculated
inputs for regions within the state from which ASUs must be designated.
This is provided as an Excel sheet with a filename like `ST_asuYY.xlsx`
where ST is the state abbreviation and YY is the year for which the ASU
is being designated. **ASUloadR** is currently designed to pull
information directly from this file, including identifying the state and
year for which data should be retrieved.

Because this file is built using public information but using
preliminary LAUS data for June of the current year, archives of these
files are not publicly available but also do not contain confidential
information. Future versions of ASUloadR may build these input files
directly, but currently the state-specific input file is required.

ASUs are required to meet three elements to be considered. First, the
region must be geographically contiguous (including corner-to-corner
intersections). Second, the region must have a population of at least
10,000. Third, the unemployment rate in the region must be at least
6.5%. The methodology in **BLSloadR** looks at each census tract with an
unemployment rate of at least 6.45%, then adds the adjacent tract with
the next-highest unemployment rate (or a labor force of 0), and
continues until the unemployment rate in the combined region is \<6.45%.
It then removes the last-added tract, designates the region as an ASU,
and continues with the next-highest remaining unused tract in the state.
It continues building regions until there are no remaining tracts with a
rate of at least 6.45%, then stops.

**Using ASUloadR**

The basic functionality of **ASUloadR** is simple. First, install the
package. Second, call the `launch_ASUloadR()` function. If you prefer,
you don’t even have to load the package into your library, just call it
directly with `ASUloadR::launch_ASUloadR()`. By default, this will
launch the **ASUloadR** Shiny app in your default browser window.

**Basic Navigation**

Within the app window, there are a series of tabs across the top. These
control the basic navigation within the app. The functionality of each
tab will be described in detail below.

-   Data Initialization: this is where you load the Excel file from BLS.

-   Load Initial ASU: here you use the data from BLS to generate an
    initial list of potential ASUs.

-   Modify ASU Selections: this is the primary window you will interact
    with. It allows for the manipulation and refinement of the data.

-   Save and Load Data: this allows you to save the current state of the
    modified data and maps to be loaded later. If you have already saved
    data, you can come straight here to load that map.

-   ASU Review and Finalization: this tab contains tools to review the
    summarized ASUs, to generate an output CSV file to review individual
    tracts, and to generate a batch TXT file that can be uploaded to
    BLS.

**Data Initialization**

To begin the ASU building process, click the `Browse` button on the left
side of the page. Once a file has been selected, an overview of the file
will appear on the right to confirm the file has successfully loaded.
You may review the contents of the columns to ensure that data appears
to be loaded correctly. This script assumes the columns are maintained
in a consistent order by BLS - changes to the structure of the file will
require updates to the structure of this code.

When review is complete, continue to the next tab - Load Initial ASU.

**Load Initial ASU**

To begin the ASU designation process, click the
`Load Tracts and Initialize ASU` button. This will execute the
tract-by-tract ASU building process. Small states may see this process
run in under 20 seconds. The largest states may take up to 5 minutes.
When the process is complete, the app will render a map to on the right
side of the page. The number of colors on this map is limited to 8, so
if more than 8 potential ASUs are identified, more than one ASU will use
the same color.

In addition, note that a table of the potential ASUs will appear below
the button. This will give the analyst a sense of how many tracts may be
worth merging into larger ASUs. In general, regions with 3 or fewer
tracts are unlikely to meet the population threshold to qualify as an
ASU.

To begin manipulating the data, proceed to the next tab, Modify ASU
Selections. Or, if the number of modifications is large or the state
takes a long time to run, skip ahead to perform an initial save of the
data on Save and Load Data.

**Modify ASU Selections**

This tab is where all edits to the ASU selections are made. A number of
tools are provided to aid in the optimization of the ASUs. In general,
*selected* tracts will be outlined in red on the map.

-   Hover over the map. Hovering the mouse over the map will display
    information about that tract useful to the selection process.

-   Click on the map. Clicking on the map will select, or unselect, a
    particular tract.

-   Select ASU Number: This dropdown allows you to select all the tracts
    in a particular ASU. If you select None, this will effectively clear
    all selected tracts.

-   Change ASU Value / Update Selected Tracts: This is how you change
    the pre-assigned ASU number. Enter the numeric value in the box
    under *Change ASU Value:* and then click the *Update Selected
    Tracts* to change the value. The numeric value remains in the box,
    providing a convenient way to keep changing tracts or groups of
    tracts to the same ASU. Further, changing the ASU number to 0 is how
    selected tracts are removed from any ASUs.

-   Show Data for Selected Tracts: This will generate a table below the
    map which has the aggregated ASU data for all selected tracts. This
    may help with determining whether it is efficient to add a tract or
    group of tracts to an existing ASU.

-   Percentile Threshold / Show Tracts with Lowest UR: This allows you
    to enter a numeric value (0-100) which will highlight the tracts
    within the current selection that have the lowest unemployment
    rates. As the analyst changes ASUs, this helps identify tracts which
    might be good candidates to remove from an ASU to add others in.
    While the algorithm will add tracts until the combined rate is as
    low as possible, it does not know whether a tract with low
    unemployment would be useful to “bridge” to a further high
    unemployment tract that could not otherwise qualify as an ASU.
    *Note: this functionality currently **removes highlighting from
    still-selected tracts**. To make changes, please Clear Selected
    Tracts, then select the tract you wish to modify.*

-   Enter a GEOID / Select a Single Tract: This functionality is most
    useful when using the CSV output that this app generates on the
    **ASU Review and Finalization** tab. Given the 11-character GEOID,
    you can input that to highlight a single tract to examine where it
    fits. This can be helpful for fine-tuning - reviewing the
    highest-unemployment tracts not included in an ASU to ensure they
    cannot be connected in to improve the ASU.

-   Reset to Initial Data: This button will reset all changes you have
    made to the state of the map after the **Load Initial ASU** process.
    For when you’ve just broken everything and want to start over. Use
    with caution!

**Save and Load Data**

This tab contains some simple options to help save and load the current
state of the map. While Nevada had only 6 initial ASUs to review other
states may have over 100! This will save the background data of the app
as an RDS file, or load data from an RDS file.

To specify a directory other than your working directory, paste that
directory into the `Save Directory Path` box.

**ASU Review and Finalization**

This will typically be the last screen in the process. Here, you may
test the ASUs you have created against the required numeric thresholds
using `Generate ASU Summary` - this is most useful for validating edge
cases, when the calculated aggregate ASU rate is less than but rounds up
to 6.45. Because the criteria for an ASU is an unemployment rate of
6.5%, a rate of 6.449% will not qualify. The TRUE/FALSE outputs in the
table provide the most reliable test for whether the ASU will qualify.

Generate LSS .txt File and Create Summary CSV will both create files in
the directory specified in the **Save and Load Data** tab (or your
working directory). The LSS TXT file should be formatted to be able to
upload to LSS directly once the ASUs are completed. The Summary CSV file
provides a handy output of all selected tracts and a useful tool to
review the selections for high-unemployment tracts that were not
included.
